// SPDX-License-Identifier: MIT
pragma solidity 0.8.26;

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import {IERC721} from "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import {IERC1155} from "@openzeppelin/contracts/token/ERC1155/IERC1155.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {IERC721Receiver} from "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import {IERC165} from "@openzeppelin/contracts/utils/introspection/IERC165.sol";
import {ILendingProtocol} from "../interfaces/ILendingProtocol.sol";
import {ICurrencyManager} from "../interfaces/ICurrencyManager.sol";
import {ICollectionManager} from "../interfaces/ICollectionManager.sol";
import {IVaultsFactory} from "../interfaces/IVaultsFactory.sol";
import {ILiquidation} from "../interfaces/ILiquidation.sol";
import {IPurchaseBundler} from "../interfaces/IPurchaseBundler.sol";
import {IRoyaltyManager} from "../interfaces/IRoyaltyManager.sol";
import {IIPAssetRegistry} from "@storyprotocol/contracts/interfaces/registries/IIPAssetRegistry.sol";

contract LendingProtocol is
    ILendingProtocol,
    Ownable,
    ReentrancyGuard,
    IERC721Receiver
{
    using SafeERC20 for IERC20;

    ICurrencyManager public currencyManager;
    ICollectionManager public collectionManager;
    IVaultsFactory public vaultsFactory;
    ILiquidation public liquidationContract;
    IPurchaseBundler public purchaseBundler;
    IRoyaltyManager public royaltyManager;
    IIPAssetRegistry public ipAssetRegistry;

    mapping(bytes32 => LoanOffer) public loanOffers;
    mapping(bytes32 => Loan) public loans;
    mapping(bytes32 => RenegotiationProposal) public renegotiationProposals;

    uint256 private offerCounter;
    uint256 private loanCounter;
    uint256 private renegotiationProposalCounter;

    struct RenegotiationProposal {
        bytes32 proposalId;
        bytes32 loanId;
        address proposer;
        address borrower;
        uint256 proposedPrincipalAmount;
        uint256 proposedInterestRateAPR;
        uint256 proposedDurationSeconds;
        bool accepted;
        bool exists;
    }

    modifier onlyLender(bytes32 loanId) {
        require(loans[loanId].lender == msg.sender, "Not lender");
        _;
    }

    modifier onlyBorrower(bytes32 loanId) {
        require(loans[loanId].borrower == msg.sender, "Not borrower");
        _;
    }

    constructor(
        address _currencyManager,
        address _collectionManager,
        address _vaultsFactory,
        address _liquidationContract,
        address _purchaseBundler,
        address _royaltyManager,
        address _ipAssetRegistry
    ) Ownable(msg.sender) {
        require(_currencyManager != address(0), "CurrencyManager zero address");
        require(
            _collectionManager != address(0),
            "CollectionManager zero address"
        );
        require(
            _liquidationContract != address(0),
            "LiquidationContract zero address"
        );
        require(
            _purchaseBundler != address(0),
            "PurchaseBundler zero address"
        );
        require(_royaltyManager != address(0), "RoyaltyManager zero address");
        require(
            _ipAssetRegistry != address(0),
            "IPAssetRegistry zero address"
        );

        currencyManager = ICurrencyManager(_currencyManager);
        collectionManager = ICollectionManager(_collectionManager);
        if (_vaultsFactory != address(0)) {
            vaultsFactory = IVaultsFactory(_vaultsFactory);
        }
        liquidationContract = ILiquidation(_liquidationContract);
        purchaseBundler = IPurchaseBundler(_purchaseBundler);
        royaltyManager = IRoyaltyManager(_royaltyManager);
        ipAssetRegistry = IIPAssetRegistry(_ipAssetRegistry);
    }

    function makeLoanOffer(OfferParams calldata params)
        external
        override
        nonReentrant
        returns (bytes32 offerId)
    {
        require(
            currencyManager.isCurrencySupported(params.currency),
            "Currency not supported"
        );
        require(params.principalAmount > 0, "Principal must be > 0");
        require(params.durationSeconds > 0, "Duration must be > 0");
        require(
            params.expirationTimestamp > block.timestamp,
            "Expiration in past"
        );

        if (params.offerType == OfferType.STANDARD) {
            require(
                params.nftContract != address(0),
                "NFT contract address needed"
            );
            require(
                collectionManager.isCollectionWhitelisted(params.nftContract),
                "Collection not whitelisted"
            );
        } else {
            // Collection Offer
            require(
                collectionManager.isCollectionWhitelisted(params.nftContract),
                "Collection not whitelisted"
            );
            require(params.totalCapacity > 0, "Total capacity must be > 0");
            require(
                params.maxPrincipalPerLoan > 0 &&
                    params.maxPrincipalPerLoan <= params.totalCapacity,
                "Invalid max principal per loan"
            );
        }

        offerCounter++;
        offerId = keccak256(
            abi.encodePacked("offer", offerCounter, msg.sender, block.timestamp)
        );

        loanOffers[offerId] = LoanOffer({
            offerId: offerId,
            lender: msg.sender,
            offerType: params.offerType,
            nftContract: params.nftContract,
            nftTokenId: params.nftTokenId,
            currency: params.currency,
            principalAmount: params.principalAmount,
            interestRateAPR: params.interestRateAPR,
            durationSeconds: params.durationSeconds,
            expirationTimestamp: params.expirationTimestamp,
            originationFeeRate: params.originationFeeRate,
            maxSeniorRepayment: 0,
            totalCapacity: params.totalCapacity,
            maxPrincipalPerLoan: params.maxPrincipalPerLoan,
            minNumberOfLoans: params.minNumberOfLoans,
            isActive: true
        });

        emit OfferMade(
            offerId,
            msg.sender,
            params.offerType,
            params.nftContract,
            params.nftTokenId,
            params.currency,
            params.principalAmount,
            params.interestRateAPR,
            params.durationSeconds,
            params.expirationTimestamp
        );
        return offerId;
    }

    function acceptLoanOffer(
        bytes32 offerId,
        address nftContract,
        uint256 nftTokenId
    ) external override nonReentrant returns (bytes32 loanId) {
        LoanOffer storage offer = loanOffers[offerId];
        require(offer.isActive, "Offer not active");
        require(offer.expirationTimestamp > block.timestamp, "Offer expired");
        require(msg.sender != offer.lender, "Cannot accept own offer");

        address collateralContract;
        uint256 collateralTokenId;
        bool isCollateralVault = false;

        if (offer.offerType == OfferType.STANDARD) {
            collateralContract = offer.nftContract;
            collateralTokenId = offer.nftTokenId;
        } else {
            collateralContract = nftContract;
            collateralTokenId = nftTokenId;
            require(
                collectionManager.isCollectionWhitelisted(collateralContract),
                "Collection not whitelisted"
            );
        }

        if (
            address(vaultsFactory) != address(0) &&
            vaultsFactory.isVault(collateralTokenId)
        ) {
            require(
                vaultsFactory.ownerOfVault(collateralTokenId) == msg.sender,
                "Not vault owner"
            );
            isCollateralVault = true;
            collateralContract = address(vaultsFactory);
        } else {
            require(
                IERC721(collateralContract).ownerOf(collateralTokenId) ==
                    msg.sender,
                "Not NFT owner"
            );
        }

        IERC721(collateralContract).safeTransferFrom(
            msg.sender,
            address(this),
            collateralTokenId
        );

        loanCounter++;
        loanId = keccak256(
            abi.encodePacked("loan", loanCounter, msg.sender, offerId)
        );
        uint64 startTime = uint64(block.timestamp);
        uint64 dueTime = startTime + uint64(offer.durationSeconds);
        uint256 originationFee = (offer.principalAmount *
            offer.originationFeeRate) / 10000;

        loans[loanId] = Loan({
            loanId: loanId,
            offerId: offerId,
            borrower: msg.sender,
            lender: offer.lender,
            nftContract: collateralContract,
            nftTokenId: collateralTokenId,
            isVault: isCollateralVault,
            currency: offer.currency,
            principalAmount: offer.principalAmount,
            interestRateAPR: offer.interestRateAPR,
            originationFeePaid: originationFee,
            startTime: startTime,
            dueTime: dueTime,
            accruedInterest: 0,
            status: LoanStatus.ACTIVE
        });

        offer.isActive = false;

        IERC20(offer.currency).safeTransferFrom(
            offer.lender,
            msg.sender,
            offer.principalAmount - originationFee
        );
        if (originationFee > 0) {
            IERC20(offer.currency).safeTransferFrom(
                offer.lender,
                offer.lender,
                originationFee
            );
        }

        emit OfferAccepted(
            loanId,
            offerId,
            msg.sender,
            offer.lender,
            collateralContract,
            collateralTokenId,
            offer.currency,
            offer.principalAmount,
            dueTime
        );
        return loanId;
    }

    function cancelLoanOffer(bytes32 offerId) external override nonReentrant {
        LoanOffer storage offer = loanOffers[offerId];
        require(offer.lender == msg.sender, "Not offer owner");
        require(offer.isActive, "Offer not active");

        offer.isActive = false;

        emit OfferCancelled(offerId, msg.sender);
    }

    function calculateInterest(bytes32 loanId) public view override returns (uint256) {
        Loan storage loan = loans[loanId];
        require(loan.status == LoanStatus.ACTIVE, "Loan not active");

        uint256 timeElapsed = block.timestamp < loan.dueTime
            ? block.timestamp - loan.startTime
            : loan.dueTime - loan.startTime;

        uint256 interest = (loan.principalAmount *
            loan.interestRateAPR *
            timeElapsed) / (365 days * 10000);

        return interest;
    }

    function repayLoan(bytes32 loanId) external override nonReentrant {
        Loan storage currentLoan = loans[loanId];
        require(currentLoan.borrower == msg.sender, "Not borrower");
        require(currentLoan.status == LoanStatus.ACTIVE, "Loan not active");
        require(
            block.timestamp <= currentLoan.dueTime,
            "Loan past due (defaulted)"
        );

        uint256 interest = calculateInterest(loanId);
        uint256 totalRepayment = currentLoan.principalAmount + interest;

        IERC20(currentLoan.currency).safeTransferFrom(
            msg.sender,
            currentLoan.lender,
            totalRepayment
        );

        IERC721(currentLoan.nftContract).safeTransferFrom(
            address(this),
            currentLoan.borrower,
            currentLoan.nftTokenId
        );

        currentLoan.status = LoanStatus.REPAID;
        currentLoan.accruedInterest = interest;

        emit LoanRepaid(
            loanId,
            msg.sender,
            currentLoan.lender,
            currentLoan.principalAmount,
            interest
        );
    }

    function claimAndRepay(bytes32 loanId) external override nonReentrant {
        Loan storage currentLoan = loans[loanId];
        require(currentLoan.borrower == msg.sender, "Not borrower");
        require(currentLoan.status == LoanStatus.ACTIVE, "Loan not active");

        address ipId = ipAssetRegistry.ipId(
            block.chainid,
            currentLoan.nftContract,
            currentLoan.nftTokenId
        );
        royaltyManager.claimRoyalty(ipId);

        uint256 royaltyBalance = royaltyManager.getRoyaltyBalance(ipId);
        uint256 interest = calculateInterest(loanId);
        uint256 totalRepayment = currentLoan.principalAmount + interest;

        if (royaltyBalance >= totalRepayment) {
            // Full repayment with royalties
            // Transfer royalty to lender
            // This assumes RoyaltyManager holds the tokens.
            // A pull from RoyaltyManager would be needed here.
            // For now, let's assume direct transfer for simplicity of this example.
            IERC20(currentLoan.currency).transferFrom(
                address(royaltyManager),
                currentLoan.lender,
                totalRepayment
            );
            currentLoan.status = LoanStatus.REPAID;
            emit LoanRepaid(
                loanId,
                msg.sender,
                currentLoan.lender,
                currentLoan.principalAmount,
                interest
            );
        } else {
            // Partial repayment
            IERC20(currentLoan.currency).transferFrom(
                address(royaltyManager),
                currentLoan.lender,
                royaltyBalance
            );
            currentLoan.principalAmount -= royaltyBalance; // Reduce principal
            // Borrower pays the rest
            uint256 remainingRepayment = totalRepayment - royaltyBalance;
            IERC20(currentLoan.currency).safeTransferFrom(
                msg.sender,
                currentLoan.lender,
                remainingRepayment
            );
            currentLoan.status = LoanStatus.REPAID;
            emit LoanRepaid(
                loanId,
                msg.sender,
                currentLoan.lender,
                totalRepayment,
                interest
            );
        }

        IERC721(currentLoan.nftContract).safeTransferFrom(
            address(this),
            currentLoan.borrower,
            currentLoan.nftTokenId
        );
    }

    // --- Implement missing ILendingProtocol functions as stubs ---

    function refinanceLoan(
        bytes32 existingLoanId,
        uint256 newPrincipalAmount,
        uint256 newInterestRateAPR,
        uint256 newDurationSeconds,
        uint256 newOriginationFeeRate
    ) external override nonReentrant returns (bytes32 newLoanId) {
        Loan storage oldLoan = loans[existingLoanId];
        require(oldLoan.status == LoanStatus.ACTIVE, "Loan not active");
        require(msg.sender != address(0), "Invalid lender");
        require(newPrincipalAmount >= oldLoan.principalAmount, "Principal must be >= old");
        require(newDurationSeconds >= oldLoan.dueTime - oldLoan.startTime, "Duration must be >= old");

        // Only allow if APR is at least 5% lower or borrower approval is required (not implemented here)
        require(newInterestRateAPR <= oldLoan.interestRateAPR * 95 / 100, "APR not improved by 5%");

        // Repay old lender
        uint256 accruedInterest = calculateInterest(existingLoanId);
        uint256 totalRepay = oldLoan.principalAmount + accruedInterest;
        IERC20(oldLoan.currency).safeTransferFrom(msg.sender, oldLoan.lender, totalRepay);

        // Update loan terms (new loanId for simplicity)
        loanCounter++;
        newLoanId = keccak256(abi.encodePacked("loan", loanCounter, oldLoan.borrower, existingLoanId));
        loans[newLoanId] = Loan({
            loanId: newLoanId,
            offerId: oldLoan.offerId,
            borrower: oldLoan.borrower,
            lender: msg.sender,
            nftContract: oldLoan.nftContract,
            nftTokenId: oldLoan.nftTokenId,
            isVault: oldLoan.isVault,
            currency: oldLoan.currency,
            principalAmount: newPrincipalAmount,
            interestRateAPR: newInterestRateAPR,
            originationFeePaid: newOriginationFeeRate,
            startTime: uint64(block.timestamp),
            dueTime: uint64(block.timestamp) + uint64(newDurationSeconds),
            accruedInterest: 0,
            status: LoanStatus.ACTIVE
        });

        oldLoan.status = LoanStatus.REPAID;

        emit LoanRefinanced(
            existingLoanId,
            newLoanId,
            oldLoan.borrower,
            oldLoan.lender,
            msg.sender,
            newPrincipalAmount,
            newInterestRateAPR,
            uint64(block.timestamp) + uint64(newDurationSeconds)
        );
    }

    function proposeRenegotiation(
        bytes32 loanId,
        uint256 proposedPrincipalAmount,
        uint256 proposedInterestRateAPR,
        uint256 proposedDurationSeconds
    ) external override nonReentrant returns (bytes32 proposalId) {
        Loan storage loan = loans[loanId];
        require(loan.status == LoanStatus.ACTIVE, "Loan not active");
        require(msg.sender == loan.lender, "Only lender can propose");

        renegotiationProposalCounter++;
        proposalId = keccak256(abi.encodePacked("proposal", renegotiationProposalCounter, loanId, msg.sender));
        renegotiationProposals[proposalId] = RenegotiationProposal({
            proposalId: proposalId,
            loanId: loanId,
            proposer: msg.sender,
            borrower: loan.borrower,
            proposedPrincipalAmount: proposedPrincipalAmount,
            proposedInterestRateAPR: proposedInterestRateAPR,
            proposedDurationSeconds: proposedDurationSeconds,
            accepted: false,
            exists: true
        });
    }

    function acceptRenegotiation(bytes32 proposalId) external override nonReentrant {
        RenegotiationProposal storage proposal = renegotiationProposals[proposalId];
        require(proposal.exists, "Proposal does not exist");
        require(!proposal.accepted, "Already accepted");
        require(msg.sender == proposal.borrower, "Only borrower can accept");

        Loan storage loan = loans[proposal.loanId];
        require(loan.status == LoanStatus.ACTIVE, "Loan not active");

        // Update loan terms
        loan.principalAmount = proposal.proposedPrincipalAmount;
        loan.interestRateAPR = proposal.proposedInterestRateAPR;
        loan.dueTime = uint64(loan.startTime + proposal.proposedDurationSeconds);

        proposal.accepted = true;

        emit LoanRenegotiated(
            proposal.loanId,
            proposal.borrower,
            proposal.proposer,
            proposal.proposedPrincipalAmount,
            proposal.proposedInterestRateAPR,
            loan.dueTime
        );
    }

    function claimCollateral(bytes32 loanId) external override nonReentrant {
        Loan storage loan = loans[loanId];
        require(loan.status == LoanStatus.ACTIVE, "Loan not active");
        require(block.timestamp > loan.dueTime, "Loan not defaulted");
        require(msg.sender == loan.lender, "Only lender can claim");

        loan.status = LoanStatus.DEFAULTED;

        IERC721(loan.nftContract).safeTransferFrom(address(this), loan.lender, loan.nftTokenId);

        emit CollateralClaimed(loanId, loan.lender, loan.nftContract, loan.nftTokenId);
    }

    function getLoan(bytes32 loanId) external view override returns (Loan memory) {
        return loans[loanId];
    }

    function getLoanOffer(bytes32 offerId) external view override returns (LoanOffer memory) {
        return loanOffers[offerId];
    }

    function isLoanRepayable(bytes32 loanId) external view override returns (bool) {
        Loan storage loan = loans[loanId];
        return loan.status == LoanStatus.ACTIVE && block.timestamp <= loan.dueTime;
    }

    function isLoanInDefault(bytes32 loanId) external view override returns (bool) {
        Loan storage loan = loans[loanId];
        return loan.status == LoanStatus.ACTIVE && block.timestamp > loan.dueTime;
    }

    // --- admin functions ---

    function setCurrencyManager(address newManager) external onlyOwner {
        require(newManager != address(0), "zero address");
        currencyManager = ICurrencyManager(newManager);
    }

    function setCollectionManager(address newManager) external onlyOwner {
        require(newManager != address(0), "zero address");
        collectionManager = ICollectionManager(newManager);
    }

    function setVaultsFactory(address newFactory) external onlyOwner {
        require(newFactory != address(0), "zero address");
        vaultsFactory = IVaultsFactory(newFactory);
    }

    function setLiquidationContract(address newContract) external onlyOwner {
        require(newContract != address(0), "zero address");
        liquidationContract = ILiquidation(newContract);
    }

    function setPurchaseBundler(address newBundler) external onlyOwner {
        require(newBundler != address(0), "zero address");
        purchaseBundler = IPurchaseBundler(newBundler);
    }

    function setRoyaltyManager(address newManager) external onlyOwner {
        require(newManager != address(0), "zero address");
        royaltyManager = IRoyaltyManager(newManager);
    }

    function setIpAssetRegistry(address newRegistry) external onlyOwner {
        require(newRegistry != address(0), "zero address");
        ipAssetRegistry = IIPAssetRegistry(newRegistry);
    }

    // --- emergency functions ---

    function emergencyWithdrawERC20(
        address token,
        address to,
        uint256 amount
    ) external onlyOwner {
        IERC20(token).safeTransfer(to, amount);
    }

    function emergencyWithdrawERC721(
        address nftContract,
        address to,
        uint256 tokenId
    ) external onlyOwner {
        IERC721(nftContract).safeTransferFrom(address(this), to, tokenId);
    }

    function emergencyWithdrawNative(address payable to, uint256 amount)
        external
        onlyOwner
    {
        (bool success, ) = to.call{value: amount}("");
        require(success, "Transfer failed");
    }

    // Receive function to allow contract to accept ETH
    receive() external payable {}
}
